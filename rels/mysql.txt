1.最左前缀：where后使用频繁的一般放在前面。A、B、C三列的组合为A,AB,ABC和where条件后列顺序没有关系
2.涉及到排序，比如order by，范围比较。列一般放在靠后的位置
3.索引不宜过多的原因
第一 空间浪费
第二 内存会消耗
第三 插入会变慢一些

4.索引列顺序和where后列顺序无关

5.在查询中，WHERE条件也是一个比较重要的因素，尽量少并且是合理的where条件是很重要的，尽量在多个条件的时候，把会提取尽量少数据量的条件放在前面，减少后一个where条件的查询时间。
 
有些where条件会导致索引无效：
 
Ø where子句的查询条件里有！=，MySQL将无法使用索引。
 
Ø where子句使用了Mysql函数的时候，索引将无效，比如：select * from tb where left(name, 4) = 'xxx'
 
Ø 使用LIKE进行搜索匹配的时候，这样索引是有效的：select * from tbl1 where name like 'xxx%'，而like '%xxx%' 时索引无效

6.1) MyISAM存储引擎索引键长度的总和不能超过1000字节;
 
　　2) BLOB和TEXT类型的列只能创建前缀索引;
 
　　3) MySQL 目前不支持函数索引;
 
　　4) 使用不等于(!= 或者 <>)的时候，MySQL 无法使用索引;
 
　　5) 过滤字段使用了函数运算(如abs(column))后，MySQL无法使用索引;
 
　　6) Join 语句中 Join 条件字段类型不一致的时候，MySQL 无法使用索引;
 
　　7) 使用LIKE操作的时候如果条件以通配符开始(如’%key…’)时，MySQL无法使用索引;

7.分页查询优化
SELECT
`CUSTOMER_ID`,`TAOBAO_ID`,`BUYER_LEVEL`,`OWN_USER`,`ECRM_LEVEL`
FROM customers t1,(
SELECT _t0.`CUSTOMER_ID` AS _c0
FROM customers _t0
WHERE _t0.`TAOBAO_ID` <> '0' AND (_t0.`BUYER_LEVEL` < 0 OR _t0.`MODIFIED_ON` < '2012-10-26 15:58:08')
LIMIT 100 offset 10000) t2
WHERE t1.`customer_id`=t2._c0

